<?php
// $Id$

/**
 * @file
 * Provides menu links for dynamic positioning of nodes based on configurable rules.
 */

/**
 * Implements hook_node_view().
 *
 * @TODO: the rule checking is tied to nodes by hook_node_view() See about
 * untethering it.
 */
function menu_position_node_view($node, $view_mode) {
  // Guh. Need a better trigger then arg() and hook_node_view().
  if ($view_mode == 'full' && arg(0) == 'node' && arg(1) == $node->nid) {
    menu_position_evaluate_rules($node->uri['path'], $node);
  }
}

/**
 * Implements hook_permission().
 */
function menu_position_permission() {
  return array(
    'administer menu positions' => array(
      'title' => t('Administer menu position rules'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function menu_position_menu() {
  module_load_include('inc', 'menu_position', 'menu_position.admin');
  return _menu_position_menu();
}

/**
 * Implements hook_theme().
 */
function menu_position_theme() {
  return array(
    'menu_position_rules_order' => array(
      'render element' => 'element',
      'file' => 'menu_position.admin.inc',
    ),
  );
}

/**
 * Implements hook_menu_position_rule_plugins().
 */
function menu_position_menu_position_rule_plugins() {
  return array(
    'node_type' => array(
      'form_callback' => 'menu_position_menu_position_rule_node_type_form',
      'condition_callback' => 'menu_position_menu_position_condition_node_type',
      'file' => 'menu_position.node_type.inc',
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function menu_position_form_menu_overview_form_alter(&$form, &$form_state) {
  module_load_include('inc', 'menu_position', 'menu_position.admin');
  _menu_position_form_menu_overview_form_alter($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function menu_position_form_menu_edit_item_alter(&$form, &$form_state) {
  module_load_include('inc', 'menu_position', 'menu_position.admin');
  _menu_position_form_menu_edit_item_alter($form, $form_state);
}

/**
 * Implements hook_menu_link_update().
 */
function menu_position_menu_link_alter(&$item) {
  if ($item['module'] == 'menu_position') {
    // Don't allow the link to be "enabled".
    $item['hidden'] = 1;
  }
}

/**
 * Implements hook_menu_link_update().
 */
function menu_position_menu_link_update($link) {
  module_load_include('inc', 'menu_position', 'menu_position.admin');
  _menu_position_menu_link_update($link);
}

/**
 * Evaluates all rules based on the given path.
 *
 * @param $path
 *   The path used to evaluate all rules.
 * @param $node
 *   The full node object if the path is a node page.
 */
function menu_position_evaluate_rules($path, $node = NULL) {
  // Retrieve the rules from the database.
  $rules = db_query('SELECT * FROM {menu_position_rules} WHERE enabled = :enabled ORDER BY weight, rid', array(':enabled' => 1));

  // Retrieve the list of menus the node's url is already in.
  $menu_names = db_query('SELECT menu_name FROM {menu_links} WHERE link_path = :path', array(':path' => $path))->fetchCol();

  // Examine each rule and check its conditions.
  foreach ($rules as $rule) {
    if (in_array($rule->menu_name, $menu_names)) {
      // If the node is already placed in the rule's menu, skip the rule.
      $rule_matches = FALSE;
    }
    else {
      // A rule with no conditions always matches.
      $rule_matches = TRUE;
      // Go through each condition, ANDing each result.
      $rule->conditions = unserialize($rule->conditions);
      foreach ($rule->conditions as $plugin => $variables) {
        // Add the current rule and node to the callback's variables.
        $variables['rule'] = $rule;
        $variables['node'] = $node;
        // Find the plugin's callback function.
        $callback = menu_position_get_condition_callback($plugin);
        if ($callback) {
          // Check if this condition matches.
          $rule_matches = $callback($variables);
        }
        else {
          // If the callback cannot be found, the condition has failed.
          $rule_matches = FALSE;
        }
        // No need to check other conditions if this condition failed.
        if (!$rule_matches) {
          break;
        }
      }
    }
    // We've found the first matching rule.
    if ($rule_matches) {

      // Retrieve menu item specified in the rule.
      $menu_item = menu_link_load($rule->mlid);

      // Clone the original router item, but insert our menu_position path.
      $router_item = $original_router_item = menu_get_item();
      $router_item['href'] = $menu_item['link_path'];
      $router_item['access'] = TRUE;

      // Temporarily override the original router item.
      menu_set_item(NULL, $router_item);

      // Copy the menu tree cache from our faked path to the original router's
      // path. We iterate through 3 levels of menu_depth: 0 - full tree, 1 -
      // primary links, 2 - secondary links.
      $tree = &drupal_static('menu_tree_page_data', array());
      foreach (array(0, 1, 2) as $menu_depth) {
        // Create a menu tree using the menu_position path.
        menu_tree_page_data($menu_item['menu_name'], $menu_depth ? $menu_depth : NULL);

        // Get the cache for the tree we just generated.
        $router_item_cid = 'links:' . $menu_item['menu_name'] . ':page-cid:' . $router_item['href'] . ':' . $GLOBALS['language']->language . ':' . (int) $router_item['access'] . ':' . (int) $menu_depth;
        $cache = cache_get($router_item_cid, 'cache_menu');
        $tree_cid = $cache->data;

        // Copy the cache to the tree that contains the original router item.
        $original_router_item_cid = 'links:' . $menu_item['menu_name'] . ':page-cid:' . $original_router_item['href'] . ':' . $GLOBALS['language']->language . ':' . (int) $original_router_item['access'] . ':' . $menu_depth;
        cache_set($original_router_item_cid, $tree_cid, 'cache_menu');

        // Ensure menu_tree_page_data's static cache is up-to-date as well.
        $tree[$original_router_item_cid] = $tree[$router_item_cid];

        // To save memory, clean up the cache since we won't need this data again.
        unset($tree[$router_item_cid]);
      }

      // Use our fake router item to influence the active trail.
      $active_trail = menu_set_active_trail();
      // After we reset the original router item, menu_get_active_breadcrumb()
      // will no longer remove the last item from the end of the trail since
      // its path won't match the path of the original router item. So we need
      // to force the breadcrumbs now.
      drupal_set_breadcrumb(menu_get_active_breadcrumb());

      // Restore the original router item.
      menu_set_item(NULL, $original_router_item);

      // If the rule matches, do not continue looking for other rules.
      break;
    }
  }
}

/**
 * Retrieves a list of information about every rule plugin.
 */
function menu_position_get_plugins() {
  $plugins = &drupal_static(__FUNCTION__, array());

  if (empty($plugins)) {
    foreach (module_implements('menu_position_rule_plugins') as $module) {
      $function = $module . '_menu_position_rule_plugins';
      if (function_exists($function)) {
        // Register each module's plugin while setting baseline defaults.
        foreach ($function() as $name => $plugin) {
          $plugins[$name] = $plugin + array(
            'module' => $module,
            'file' => '',
            'form_callback' => $module . 'menu_position_rule_' . $name . '_form',
            'condition_callback' => $module . 'menu_position_condition_' . $name,
          );
        }
      }
    }
  }

  return $plugins;
}

/**
 * Loads the include file containing a condition's callback function definition.
 *
 * @param $plugin
 *   The name of the 
 * @return
 *   The name of the callback function, or FALSE if it could not be found.
 */
function menu_position_get_condition_callback($plugin) {
  $plugins = menu_position_get_plugins();
  $callback = !empty($plugins[$plugin]['condition_callback']) ? $plugins[$plugin]['condition_callback'] : FALSE;

  if ($callback && !function_exists($callback)) {
    // Load the specified include file.
    if (!empty($plugins[$plugin]['file'])) {
      $file = pathinfo($plugins[$plugin]['file']);
      module_load_include($file['extension'], $plugins[$plugin]['module'], $file['filename']);
    }
    // Note if the callback still cannot be found.
    if (!function_exists($callback)) {
      $callback = FALSE;
    }
  }

  return $callback;
}
